#!/bin/perl -w
#************************************************************************
#   $Version:$
#   Package	: xmt_cm
#   Purpose	: filter git blobs on checkout & commit:
#		  1. expand (smudge) or unexpand (clean) keywords upon git checkout/commit.
#		  2. instrument files for execution tracing upon git checkout.
#		
#		  1. expand (smudge) or unexpand (clean) keywords upon git checkout/commit
#		  so that keywords of the form:	$keyword:$ 
#		  are transformed into:		$keyword: value $
#		  and vice-versa.
#		  Keywords are as documented in "git log PRETTY FORMAT format:<string>"
#		  The compound "Version" keyword expands to a fully qualified 
#		  version identifier suitable for release identification.
#		  	 $ Version: <Tag>-<BuildNum> [<Branch>] $ 
#		  (see line 3 above for example).
#   		  If a filename is specified, input is read from the named file,
#		  otherwise input is read from stdin & written to stdout.
#		  Alternatively, if the --process flag is specified, git_fiter operates 
#		  as a long-running-process reading/writing Git Filter Protocol v2.
#		  If the --list flag is specified, git_filter just prints keyword 
#		  names & values to stdout, performing no substitution.
#
#		  2. instrument files for execution tracing upon git checkout.
#		  instruments the files on checkout to capture execution history by xhist.
#		  This is achieved by appending a write to a circular buffer after each
#		  semicolon terminating an executable statment.
#                 --xhist produces a map file at instrumentation time,
#                 for use by xhist_report to reconstruct the collected
#                 execution trace and present it in human-readable form.
#                 The map file is specified by
#		  --xhist_db=<pathname>
#
#   Synopsis	: git_filter [<options>] [file]
#   	 --help		print help message & exit.
#	 --expand=<branchspec> only if in a branch matching regex pattern <branchspec>,
#	  	 	expand (i.e. smudge) all keywords of the form \$Keyword:\$ 
#                       found in stdin and write substituted data stream to stdout.
#                       (e.g.  git_filter --expand="release|test" )
#	 --unexpand	unexpand (i.e. clean) all keyword values found in stdin, 
#			and write cleaned data stream to stdout.
#   	 --list		print expanded keyword values to stdout; do no substitution.
#   	 --verbose	list keyword labels with their expanded values to stdout.
#	 --binary      force substitutions in binary files; 
#			by defualt substitution only occurs in ascii files.
#	 --process      operate as a git long running process using Git filter protocol v2.
#	 --fname=<pathspec>	read contents of file from STDIN but use <pathspec>
#			as the file name for instrumentation purposes
#	 --xhist=<branchspec> only if in a branch matching regex pattern <branchspec>,
#	 		instrument files for execution history capture on checkout
#	 --xhist_map=pathname	write execution history filename map to <pathname>.
#	 --xtest=<branchspec> only if in a branch matching regex pattern <branchspec>,
#	 		instrument files for whitebox test on checkout
#	 --unxhist	unxhist (i.e. clean) xhist instrumentation found in stdin, 
#			and write cleaned data stream to stdout.
#	 --unxtest	uninstrument (i.e. clean) xtest instrumentation found in stdin, 
#			and write cleaned data stream to stdout.
#	 --debug	when used with --process, write packet trace log to /tmp/git_filter.log
#
#  Copyright 2018 Visionary Research Inc.   All rights reserved.
#  			legal@visionary-research.com
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
#  
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License. 
#************************************************************************

use strict;

# perl expects to find the required XMT modules installed into
# the standard place that CPAN modules are installed:  
# this is found by running perl -V:installsitelib
# to instead use a develop version of the XMT modules uncomment the following lines.
BEGIN {unshift(@INC, "$ENV{XMTXHIST}/bin");}
BEGIN {unshift(@INC, "$ENV{XMTXTEST}/bin");}
use XMT::Xhist;
use XMT::Xtest;

use Getopt::Long;
use Path::Tiny qw(path);
use POSIX qw(strftime);

(my $pgmname = $0) =~ s{.*/}{};	# rootname of executed script
my %kw_specified = ();

# construct the help message
my $help_msg = sprintf( <<__END__, join("\n                ", keys(%XMT::Xkeyword::kw)) );
$pgmname [<options>] [file]
  --expand=<branchspec> only if in a branch matching regex pattern <branchspec>,
                expand (i.e. smudge) all keywords of the form \$Keyword:\$ 
                found in stdin and write substituted data stream to stdout.
                (e.g.  git_filter --expand="release|test" )
  --list        print all recognized keyword values to stdout
  --list [keyword,keyword, ...]  print specified keyword values to stdout
                Recognized keywords include: 
                %s
  --verbose     list keyword labels with their expanded values to stdout
  --binary     force substitutions in binary files; 
                by defualt substitution only occurs in ascii files
  --process     operate as a git long running process using Git filter protocol v2
  --xhist=<branchspec> only if in a branch matching regex pattern <branchspec>,
                instrument files for execution history capture on checkout
  --xhist_map=pathname   write execution history filename map to <pathname>
  --xtest=<branchspec> only if in a branch matching regex pattern <branchspec>,
                instrument files for whitebox test on checkout
  --unexpand    unexpand (i.e. clean) all keyword values found in stdin, 
                and write cleaned data stream to stdout
  --unxhist     uninstrument (i.e. clean) xhist instrumentation found in stdin, 
                and write cleaned data stream to stdout.
  --unxtest     uninstrument (i.e. clean) xtest instrumentation found in stdin, 
                and write cleaned data stream to stdout.
  --fname=<pathspec>    read contents of file from STDIN but use <pathspec>
                as the file name for instrumentation purposes
  --debug       when used with --process, write packet trace log to /tmp/git_filter.log
__END__

# parse commandline options
my %opt = ();
GetOptions( \%opt, "help", "verbose", "expand=s", "unexpand", "list:s@", "binary", 
	    "process", "debug", "xhist=s", "unxhist", "xhist_map=s", "fname=s",
	    "xtest=s", "unxtest" ) 
	    or die $help_msg;

# "expand", "unexpand" and "list" are mutually exclusive.
# at least one of "expand", "unexpand", "list", "xhist" or "unxhist" must be present.
# all other args are optional.
die "$help_msg" if defined $opt{'help'};
my @mutually_exclusive = map { /expand|unexpand|list/ ? $_ : () } keys %opt;
die "$help_msg" if scalar(@mutually_exclusive) > 1;
die "$help_msg" if (!defined $opt{'expand'} and !defined $opt{'unexpand'} 
    and !defined $opt{'list'} and !defined $opt{'xhist'} and !defined $opt{'unxhist'});

if (defined $opt{'debug'})
{
    my $f = "/tmp/$pgmname.log";
    open( LOG, ">$f" ) or  die "$f: $!\n";
}


## list keyword values if any were requested
if (defined $opt{'list'})
{
    foreach $k (sort keys %kw_specified)
    {
	printf STDOUT "%s%s\n", 
		(defined $opt{'verbose'} ? sprintf("%-18s", "\$$k:\$") : ""), 
		$kw{$k}{val};
    }
    exit 0;  # we're done.
}

## if --list was not specified, then we are in substitution mode,
## operating either in standalone mode or process mode.
if (defined $opt{'process'})
{
    process_main();
}
else
{
    standalone_main();
}
exit 0;  # we're done.


#************************************************************************
# standalone_main: main processing loop for standalone filter mode
#************************************************************************
sub standalone_main
{
    my ($xh, $xt);

    # if a filename was given on the commandline, read its contents, 
    # otherwise read from stdin & use the --fname option as the filename.
    if (scalar(@ARGV) >= 1)
    {
	$opt{fname} = $ARGV[0];
	$opt{srcbuf} = path($opt{fname})->slurp;		# slurp entire file
    }
    else
    {
	$opt{srcbuf} = do { local $/ = undef; <STDIN> };	# slurp stdin
    }
    my $is_ascii = ! ($opt{srcbuf} =~ /[[:^ascii:]]/);	# check for non-ascii chars

    ## perform substitutions & write the output.
    if ($is_ascii || defined $opt{'binary'})
    {
	# XTEST FIRST.
	# do xtest instrumentation if we are in a 
	# branch specified for xtest instrumentation.
	if ( defined $opt{'xtest'} and $kw{'Branch'}{val} =~ /$opt{'xtest'}/ )
	{
	    $xt = XMT::Xtest::new(\%opt)	or die "$help_msg";
	    $opt{srcbuf} = $xt->instrument(); 
	}
	elsif ( defined $opt{'unxhist'} )
	{
	    $xt = XMT::Xtest::new(\%opt)	or die "$help_msg";
	    $opt{srcbuf} = $xt->uninstrument();
	}

	# XHIST SECOND.
	# do xhist instrumentation if we are in a 
	# branch specified for xhist instrumentation.
	if ( defined $opt{'xhist'} and $kw{'Branch'}{val} =~ /$opt{'xhist'}/ )
	{
	    $xh = XMT::Xhist::new(\%opt)	or die "$help_msg";
	    $opt{srcbuf} = $xh->instrument(); 
	    $xh->printmap();	
	}
	elsif ( defined $opt{'unxhist'} )
	{
	    $xh = XMT::Xhist::new(\%opt)	or die "$help_msg";
	    $opt{srcbuf} = $xh->uninstrument();
	}

	# KEYWORD EXPANSION LAST.
	# do keyword expansion if we are in a 
	# branch specified for keyword expansion.
	if ( defined $opt{'expand'}  and $kw{'Branch'}{val} =~ /$opt{'expand'}/ )
	{
	    kw_expand( \$opt{srcbuf} );
	}
	elsif (defined $opt{'unexpand'})
	{
	    kw_unexpand( \$opt{srcbuf} );
	}
	
    }
    print STDOUT $opt{srcbuf};
}

#************************************************************************
# kw_expand:  perform keyword expansion on buffer passed by reference 
#************************************************************************
sub kw_expand
{
    my $buf_ref = shift;
    my $k;

    foreach $k ( keys %kw )
    {
	$$buf_ref =~ s/\$$k:\$/\$$k: $kw{$k}{val} \$/g;
    }
}

#************************************************************************
# kw_unexpand:  perform keyword cleaning on buffer passed by reference 
#************************************************************************
sub kw_unexpand
{
    my $buf_ref = shift;
    my $k;

    foreach $k ( keys %kw )
    {
	$$buf_ref =~ s/\$$k:.*?\$/\$$k:\$/g;
    }
}

#************************************************************************
# the following code implementing the git filter protocol v2, is adapted from 
# https://github.com/git/git/blob/master/contrib/long-running-filter/example.pl
# See Documentation/gitattributes.txt, section "Filter Protocol"
# Credit to the authors.
#************************************************************************

sub process_main
{
    my $MAX_PACKET_CONTENT_SIZE = 65516;
    my ($rc, $str);
    my ($command, $packet);
    my ($xh, $xt);

    # receive handshake
    ($rc, $str) = packet_read(); chomp($str);
    die "error: expected 'git-filter-client', got $str" if ( $rc != 0 || $str ne "git-filter-client" );

    ($rc, $str) = packet_read(); chomp($str);
    die "error: expected 'version=2', got $str"	if ( $rc != 0 || $str ne "version=2" );         

    while ( (($rc, $str) = packet_read()) && $rc == 0 ) { ; }	# ignore additional versions

    # send response
    packet_txt_write("git-filter-server");
    packet_txt_write("version=2");
    packet_flush();

    #  receive capabilities
    ($rc, $str) = packet_read(); chomp($str);
    die "error: expected 'capability=clean', got $str"	if ( $rc != 0 || $str ne "capability=clean" );         
    ($rc, $str) = packet_read(); chomp($str);
    die "error: expected 'capability=smudge', got $str"	if ( $rc != 0 || $str ne "capability=smudge" );         
    while ( (($rc, $str) = packet_read()) && $rc == 0 ) { ; }	# ignore additional capabilities

    # send response
    packet_txt_write("capability=clean");
    packet_txt_write("capability=smudge");
    packet_flush();

    # receive command & data; perform filter & send response
    while (1) 
    {
	($rc, $command)  = packet_read(); chomp($command);
	$command  =~ s/command=//;
	($rc, $opt{fname}) = packet_read(); chomp($opt{fname});
	$opt{fname} =~ s/pathname=//;
	die "bad pathname $opt{fname}" if ( $opt{fname} eq "" );

	packet_read();	# "flush" packet 0000 follows command
	$opt{srcbuf} = "";
	binmode(STDIN);
	my $done = 0;
	my $fragment = '';
	while ( !$done ) # handle packet fragmentation 
	{
	    ($done, $fragment) = packet_read();
	    $opt{srcbuf} .= $fragment;
	}

	# entire buffer has been read.  Now do the command.
	if ( $command =~ /clean/ ) 
	{
	    ### Perform clean here ###
	    kw_unexpand( \$opt{srcbuf} );

	    if ( defined $opt{'unxhist'} )
	    {
		$xh = XMT::Xhist::new(\%opt)	or die "$help_msg";
		$opt{srcbuf} = $xh->uninstrument();
	    }

	    if ( defined $opt{'unxtest'} )
	    {
		$xt = XMT::Xtest::new(\%opt)	or die "$help_msg";
		$opt{srcbuf} = $xt->uninstrument();
	    }
	}
	elsif ( $command =~ /smudge/ ) 
	{
	    ### Perform smudge here ###

	    # XTEST FIRST.
	    # do xtest instrumentation if we are in a 
	    # branch specified for xtest instrumentation.
	    if ( defined $opt{'xtest'} and $kw{'Branch'}{val} =~ /$opt{'xtest'}/ )
	    {
		$xt = XMT::Xtest::new(\%opt)	or die "$help_msg";
		$opt{srcbuf} = $xt->instrument(); 
	    }

	    # XHIST SECOND.
	    # do xhist instrumentation if we are in a 
	    # branch specified for xhist instrumentation.
	    if (defined $opt{'xhist'} and $kw{'Branch'}{val} =~ /$opt{'xhist'}/ )
	    {
		$xh = XMT::Xhist::new(\%opt)	or die "$help_msg";
		$opt{srcbuf} = $xh->instrument();
	    }

	    # do keyword expansion if we are in a 
	    # branch specified for keyword expansion.
	    if ( defined $opt{'expand'} and $kw{'Branch'}{val} =~ /$opt{'expand'}/ )
	    {
		kw_expand( \$opt{srcbuf} );
	    }
	}
	else 
	{
	    die "bad command '$command'";
	}

	packet_txt_write("status=success");
	packet_flush();
	while ( length($opt{srcbuf}) > 0 ) 
	{
	    $packet = substr( $opt{srcbuf}, 0, $MAX_PACKET_CONTENT_SIZE );
	    packet_bin_write($packet);
	    if ( length($opt{srcbuf}) > $MAX_PACKET_CONTENT_SIZE ) 
	    {
		$opt{srcbuf} = substr( $opt{srcbuf}, $MAX_PACKET_CONTENT_SIZE );
	    }
	    else 
	    {
		$opt{srcbuf} = "";
	    }
	}
	packet_flush();    # flush content
	packet_flush();    # empty list, keep "status=success" unchanged
    }
    $xh->printmap();	
}

sub packet_read 
{
   my ($buf, $pkt_size, $bytes_read);
 
    $bytes_read = read STDIN, $buf, 4;
    if ( $bytes_read == 0 ) 
    {

	# EOF - Git stopped talking to us!
	exit();
    }
    elsif ( $bytes_read != 4 ) 
    {
	die "invalid packet: '$buf'";
    }
    $pkt_size = hex($buf);
    if ( $pkt_size == 0 ) 
    {
	dbg_log("> 0000");
	return ( 1, "" );
    }
    elsif ( $pkt_size > 4 ) 
    {
	my $content_size = $pkt_size - 4;
	$bytes_read = read STDIN, $buf, $content_size;
	if ( $bytes_read != $content_size ) 
	{
	    die "invalid packet ($content_size bytes expected; $bytes_read bytes read)";
	}
	dbg_log("> $buf");
	return ( 0, $buf );
    }
    else 
    {
	die "invalid packet size: $pkt_size";
    }
}

sub packet_bin_write 
{
    my $buf = shift;
    print STDOUT sprintf( "%04x", length($buf) + 4 );
    print STDOUT $buf;
    STDOUT->flush();
}

sub packet_txt_write 
{
    packet_bin_write( $_[0] . "\n" );
    dbg_log("< " . $_[0]);
}

sub packet_flush 
{
    print STDOUT sprintf( "%04x", 0 );
    STDOUT->flush();
    dbg_log("< 0000");
}

sub dbg_log
{
    my $str = shift;
    print LOG "$str\n" if fileno LOG;
}

